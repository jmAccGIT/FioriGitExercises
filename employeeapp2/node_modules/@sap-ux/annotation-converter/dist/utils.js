"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.addGetByValue = exports.createIndexedFind = exports.lazy = exports.Decimal = exports.isComplexTypeDefinition = exports.unalias = exports.alias = exports.substringBeforeLast = exports.substringBeforeFirst = exports.splitAtLast = exports.splitAtFirst = exports.TermToTypes = exports.EnumIsFlag = exports.defaultReferences = void 0;
var VocabularyReferences_1 = require("@sap-ux/vocabularies-types/vocabularies/VocabularyReferences");
Object.defineProperty(exports, "defaultReferences", { enumerable: true, get: function () { return VocabularyReferences_1.VocabularyReferences; } });
var EnumIsFlag_1 = require("@sap-ux/vocabularies-types/vocabularies/EnumIsFlag");
Object.defineProperty(exports, "EnumIsFlag", { enumerable: true, get: function () { return EnumIsFlag_1.EnumIsFlag; } });
var TermToTypes_1 = require("@sap-ux/vocabularies-types/vocabularies/TermToTypes");
Object.defineProperty(exports, "TermToTypes", { enumerable: true, get: function () { return TermToTypes_1.TermToTypes; } });
function splitAt(string, index) {
    return index < 0 ? [string, ''] : [string.substring(0, index), string.substring(index + 1)];
}
function substringAt(string, index) {
    return index < 0 ? string : string.substring(0, index);
}
/**
 * Splits a string at the first occurrence of a separator.
 *
 * @param string    The string to split
 * @param separator Separator, e.g. a single character.
 * @returns An array consisting of two elements: the part before the first occurrence of the separator and the part after it. If the string does not contain the separator, the second element is the empty string.
 */
function splitAtFirst(string, separator) {
    return splitAt(string, string.indexOf(separator));
}
exports.splitAtFirst = splitAtFirst;
/**
 * Splits a string at the last occurrence of a separator.
 *
 * @param string    The string to split
 * @param separator Separator, e.g. a single character.
 * @returns An array consisting of two elements: the part before the last occurrence of the separator and the part after it. If the string does not contain the separator, the second element is the empty string.
 */
function splitAtLast(string, separator) {
    return splitAt(string, string.lastIndexOf(separator));
}
exports.splitAtLast = splitAtLast;
/**
 * Returns the substring before the first occurrence of a separator.
 *
 * @param string    The string
 * @param separator Separator, e.g. a single character.
 * @returns The substring before the first occurrence of the separator, or the input string if it does not contain the separator.
 */
function substringBeforeFirst(string, separator) {
    return substringAt(string, string.indexOf(separator));
}
exports.substringBeforeFirst = substringBeforeFirst;
/**
 * Returns the substring before the last occurrence of a separator.
 *
 * @param string    The string
 * @param separator Separator, e.g. a single character.
 * @returns The substring before the last occurrence of the separator, or the input string if it does not contain the separator.
 */
function substringBeforeLast(string, separator) {
    return substringAt(string, string.lastIndexOf(separator));
}
exports.substringBeforeLast = substringBeforeLast;
/**
 * Transform an unaliased string representation annotation to the aliased version.
 *
 * @param references currentReferences for the project
 * @param unaliasedValue the unaliased value
 * @returns the aliased string representing the same
 */
function alias(references, unaliasedValue) {
    if (!references.reverseReferenceMap) {
        references.reverseReferenceMap = references.reduce((map, ref) => {
            map[ref.namespace] = ref;
            return map;
        }, {});
    }
    if (!unaliasedValue) {
        return unaliasedValue;
    }
    const [namespace, value] = splitAtLast(unaliasedValue, '.');
    const reference = references.reverseReferenceMap[namespace];
    if (reference) {
        return `${reference.alias}.${value}`;
    }
    else if (unaliasedValue.includes('@')) {
        // Try to see if it's an annotation Path like to_SalesOrder/@UI.LineItem
        const [preAlias, postAlias] = splitAtFirst(unaliasedValue, '@');
        return `${preAlias}@${alias(references, postAlias)}`;
    }
    else {
        return unaliasedValue;
    }
}
exports.alias = alias;
/**
 * Transform an aliased string representation annotation to the unaliased version.
 *
 * @param references currentReferences for the project
 * @param aliasedValue the aliased value
 * @returns the unaliased string representing the same
 */
function unalias(references, aliasedValue) {
    if (!references.referenceMap) {
        references.referenceMap = references.reduce((map, ref) => {
            map[ref.alias] = ref;
            return map;
        }, {});
    }
    if (!aliasedValue) {
        return aliasedValue;
    }
    const [vocAlias, value] = splitAtFirst(aliasedValue, '.');
    const reference = references.referenceMap[vocAlias];
    if (reference) {
        return `${reference.namespace}.${value}`;
    }
    else if (aliasedValue.includes('@')) {
        // Try to see if it's an annotation Path like to_SalesOrder/@UI.LineItem
        const [preAlias, postAlias] = splitAtFirst(aliasedValue, '@');
        return `${preAlias}@${unalias(references, postAlias)}`;
    }
    else {
        return aliasedValue;
    }
}
exports.unalias = unalias;
/**
 * Differentiate between a ComplexType and a TypeDefinition.
 *
 * @param complexTypeDefinition
 * @returns true if the value is a complex type
 */
function isComplexTypeDefinition(complexTypeDefinition) {
    return (!!complexTypeDefinition && complexTypeDefinition._type === 'ComplexType' && !!complexTypeDefinition.properties);
}
exports.isComplexTypeDefinition = isComplexTypeDefinition;
function Decimal(value) {
    return {
        isDecimal() {
            return true;
        },
        valueOf() {
            return value;
        },
        toString() {
            return value.toString();
        }
    };
}
exports.Decimal = Decimal;
/**
 * Defines a lazy property.
 *
 * The property is initialized by calling the init function on the first read access, or by directly assigning a value.
 *
 * @param object    The host object
 * @param property  The lazy property to add
 * @param init      The function that initializes the property's value
 */
function lazy(object, property, init) {
    const initial = Symbol('initial');
    let _value = initial;
    Object.defineProperty(object, property, {
        enumerable: true,
        get() {
            if (_value === initial) {
                _value = init();
            }
            return _value;
        },
        set(value) {
            _value = value;
        }
    });
}
exports.lazy = lazy;
/**
 * Creates a function that allows to find an array element by property value.
 *
 * @param array     The array
 * @param property  Elements in the array are searched by this property
 * @returns A function that can be used to find an element of the array by property value.
 */
function createIndexedFind(array, property) {
    const index = new Map();
    return function find(value) {
        const element = index.get(value);
        if ((element === null || element === void 0 ? void 0 : element[property]) === value) {
            return element;
        }
        return array.find((element) => {
            if (!(element === null || element === void 0 ? void 0 : element.hasOwnProperty(property))) {
                return false;
            }
            const propertyValue = element[property];
            index.set(propertyValue, element);
            return propertyValue === value;
        });
    };
}
exports.createIndexedFind = createIndexedFind;
/**
 * Adds a 'get by value' function to an array.
 *
 * If this function is called with addIndex(myArray, 'name'), a new function 'by_name(value)' will be added that allows to
 * find a member of the array by the value of its 'name' property.
 *
 * @param array      The array
 * @param property   The property that will be used by the 'by_{property}()' function
 * @returns The array with the added function
 */
function addGetByValue(array, property) {
    const indexName = `by_${property}`;
    if (!array.hasOwnProperty(indexName)) {
        Object.defineProperty(array, indexName, { writable: false, value: createIndexedFind(array, property) });
    }
    else {
        throw new Error(`Property '${indexName}' already exists`);
    }
    return array;
}
exports.addGetByValue = addGetByValue;
//# sourceMappingURL=utils.js.map